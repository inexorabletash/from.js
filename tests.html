<!DOCTYPE html>
<title>from.js - "LINQ"ish helpers for ECMAScript</title>
<link rel=stylesheet href="https://code.jquery.com/qunit/qunit-1.20.0.css">
<script src="https://code.jquery.com/qunit/qunit-1.20.0.js"></script>
<script src="from.js"></script>
<div id="qunit"></div>
<script>
QUnit.test('from.js', function(assert) {

  var a = [0, 1, 2, 3, 4];
  var people = [{id: 123, name: 'alice'}, {id: 7, name: 'bob'}];
  var pets = [{name: 'daisy', owner: 123}, {name: 'fido', owner: 7}, {name: 'speak', owner: 123}];
  var keyed = [
    {pk: 5, sk: 14, name: 'a'},
    {pk: 4, sk: 15, name: 'b'},
    {pk: 6, sk: 13, name: 'c'},
    {pk: 4, sk: 16, name: 'd'},
    {pk: 5, sk: 12, name: 'e'}
  ];
  var mixed = [1, 2, 3, '1', '2', '3'];
  var lazy = function*() { throw new Error('should not be called'); };

  var square = n => n * n;
  var odd = n => !!(n % 2);
  var even = n => !(n % 2);
  var sum = (a, b) => a + b;
  var cmp = (a, b) => a < b ? -1 : a > b ? 1 : 0;
  var icase = (a, b) => String(a).toUpperCase() === String(b).toUpperCase();
  var itype = (a, b) => a == b;

  function assert_equals(expr, expected) {
    var actual = eval(expr);
    if (Array.isArray(expected))
      actual = Array.from(actual);
    assert.deepEqual(actual, expected, expr + ' ==> ' + actual);
  }
  function assert_throws(expr, ex, msg) {
    assert.throws(function() { eval(expr); }, ex, expr + ' ' + (msg || 'should throw'));
  }
  function assert_chains(expr) {
    assert.ok(eval(expr) instanceof Enumerable, expr + ' chains');
  }
  function assert_nothrow(expr, msg) {
    assert.ok((eval(expr), true), expr + ' ' + (msg || 'should not throw'));
  }

  // ---------------------------------------------------------------

  assert_equals('from(a).aggregate(sum)', 10);
  assert_equals('from(a).aggregate(sum, 100)', 110);
  assert_equals('from(a).aggregate(sum, 0, r=>"$"+r)', '$10');

  assert_equals('from(a).all(odd)', false);
  assert_equals('from(a).all(i => i >= 0)', true);

  assert_equals('from(a).any(odd)', true);
  assert_equals('from(a).any(i => i > 5)', false);

  assert_equals('from(a).average()', 2);
  assert_equals('from(a).average(i=>i*10)', 20);

  assert_equals('from(a).concat(a)', [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]);
  assert_nothrow('from(lazy()).concat(lazy())', 'is lazy');
  assert_chains('from(a).concat(a)');

  assert_equals('from(a).contains(1)', true);
  assert_equals('from(a).contains(13)', false);
  assert_equals('from(["a"]).contains(["A"], icase)', true);
  assert_equals('from(["a"]).contains(["B"], icase)', false);

  assert_equals('from(a).count()', 5);
  assert_equals('from(a).count(i=>i>0)', 4);

  assert_equals('from([1,2]).defaultIfEmpty("a")', [1, 2]);
  assert_equals('from([]).defaultIfEmpty("a")', ['a']);
  assert_nothrow('from(lazy()).defaultIfEmpty("a")', 'is lazy');

  assert_equals('from([1,2,3,1,2,3]).distinct()', [1, 2, 3]);
  assert_equals('from(mixed).distinct(itype)', [1, 2, 3]);
  assert_nothrow('from(lazy()).distinct()', 'is lazy');

  assert_equals('from(a).elementAt(2)', 2);
  assert_throws('from(a).elementAt(-1)', RangeError);
  assert_throws('from(a).elementAt(7)', RangeError);

  assert_equals('from(a).elementAtOrDefault(2, NaN)', 2);
  assert_equals('from(a).elementAtOrDefault(-1, NaN)', NaN);
  assert_equals('from(a).elementAtOrDefault(7, NaN)', NaN);

  assert_equals('Enumerable.empty()', []);

  assert_equals('from(a).except([2, 3])', [0, 1, 4]);
  assert_equals('from(mixed).except([2], itype)', [1, 3, '1', '3']);
  assert_nothrow('from(lazy()).except([2, 3])', 'is lazy');
  assert_chains('from(a).except([2, 3])');

  assert_equals('from(a).first()', 0);
  assert_equals('from(a).first(odd)', 1);
  assert_throws('from([]).first()', RangeError);
  assert_throws('from(a).first(i=>i<0)', RangeError);

  assert_equals('from(a).firstOrDefault("a")', 0);
  assert_equals('from(a).firstOrDefault("a", odd)', 1);
  assert_equals('from([]).firstOrDefault("a")', 'a');
  assert_equals('from(a).firstOrDefault("a", i=>i<0)', 'a');

  assert_equals('from(keyed).groupBy(r=>r.pk).count()', 3);
  assert_equals('from(keyed).groupBy(r=>r.pk).select(g=>g[0])', [5, 4, 6]);
  assert_equals('from(keyed).groupBy(r=>r.pk).select(g=>g[1]).elementAt(0).map(o=>o.name)', ['a', 'e']);
  assert_equals('from(keyed).groupBy(r=>r.pk).select(g=>g[1]).elementAt(1).map(o=>o.name)', ['b', 'd']);
  assert_equals('from(keyed).groupBy(r=>r.pk).select(g=>g[1]).elementAt(2).map(o=>o.name)', ['c']);
  assert_equals('from(keyed).groupBy(r=>r.pk, (a,b)=>!((a+b)%2)).count()', 2);
  assert_equals('from(keyed).groupBy(r=>r.pk, (a,b)=>!((a+b)%2)).select(g=>g[0])', [5, 4]);
  assert_nothrow('from(lazy()).groupBy(odd)', 'is lazy');

  assert_equals('from(a).intersect([2, 3, 5])', [2, 3]);
  assert_equals('from(mixed).intersect([2, 5], itype)', [2]);
  assert_nothrow('from(lazy()).intersect([2, 3, 5])', 'is lazy');
  assert_chains('from(a).intersect([2, 3, 5])');

  assert_equals('from(people).join(pets, o=>o.id, i=>i.owner, (o, p) => o.name + " - " + p.name)',
                ['alice - daisy', 'alice - speak', 'bob - fido']
  );
  assert_equals('from(people).join(pets, o=>o.id, i=>String(i.owner), (o, p) => o.name + " - " + p.name, itype)',
                ['alice - daisy', 'alice - speak', 'bob - fido']
  );
  assert_nothrow('from(lazy()).join(lazy(), i => i, i => i, (a, b) => 0)', 'is lazy');

  assert_equals('from(a).last()', 4);
  assert_equals('from(a).last(odd)', 3);
  assert_throws('from([]).last()', RangeError);
  assert_throws('from(a).last(i=>i<0)', RangeError);

  assert_equals('from([1, 2, 3]).lastOrDefault(NaN)', 3);
  assert_equals('from([]).lastOrDefault(NaN)', NaN);
  assert_equals('from([1, 2, 3]).lastOrDefault(NaN, i => i < 2)', 1);
  assert_equals('from([1, 2, 3]).lastOrDefault(NaN, i => i > 5)', NaN);

  assert_equals('from(a).max()', 4);
  assert_equals('from(a).max(i=>-i)', 0);
  assert_throws('from([]).max()', RangeError);

  assert_equals('from(a).min()', 0);
  assert_equals('from(a).min(i=>-i)', 4);
  assert_throws('from([]).min()', RangeError);

  assert_equals('from(people).orderBy(e=>e.id).select(e=>e.name)', ['bob', 'alice']);
  assert_equals('from(people).orderBy(e=>e.id,(a,b)=>-cmp(a,b)).select(e=>e.name)', ['alice', 'bob']);
  assert_nothrow('from(lazy()).orderBy(e=>e)', 'is lazy');

  assert_equals('from(people).orderByDescending(e=>e.id).select(e=>e.name)', ['alice', 'bob']);
  assert_equals('from(people).orderByDescending(e=>e.id,(a,b)=>-cmp(a,b)).select(e=>e.name)', ['bob', 'alice']);
  assert_nothrow('from(lazy()).orderByDescending(e=>e)', 'is lazy');

  assert_equals('Enumerable.range(5, 3)', [5, 6, 7]);

  assert_equals('Enumerable.repeat(1, 2)', [1, 1]);

  assert_equals('from(a).reverse()', [4, 3, 2, 1, 0]);
  assert_nothrow('from(lazy()).reverse()', [4, 3, 2, 1, 0], 'is lazy');

  assert_equals('from(a).select(square)', [0, 1, 4, 9, 16]);
  assert_equals('from("abc").select((i,n)=>i+n)', ['a0', 'b1', 'c2']);
  assert_nothrow('from(lazy()).select(square)', 'is lazy');
  assert_chains('from(a).select(square)');

  assert_equals('from([{n:[1,2]}, {n:[3,4]}]).selectMany(o=>o.n)', [1, 2, 3, 4]);
  assert_equals('from([{n:["a","b"]}, {n:["c"]}]).selectMany((o,i)=>o.n.map(c=>c+i))', ['a0', 'b0', 'c1']);
  assert_equals('from([{s: "a", n:[1,2]}, {s: "b", n:[3,4]}]).selectMany(o=>o.n, (a, b) => a.s + "/" + b)', ['a/1', 'a/2', 'b/3', 'b/4']);
  assert_nothrow('from(lazy()).selectMany(o=>o.n)', 'is lazy');

  assert_equals('from(a).sequenceEqual(a)', true);
  assert_equals('from(a).sequenceEqual([4,3,2,1,0])', false);
  assert_equals('from(a).sequenceEqual([])', false);
  assert_equals('from(a).sequenceEqual(["0", "1", "2", "3", "4"], itype)', true);

  assert_equals('from([1]).single()', 1);
  assert_throws('from(a).single()', RangeError);
  assert_throws('from([]).single()', RangeError);
  assert_equals('from(a).single(i => i > 3)', 4);
  assert_throws('from(a).single(i => i > 2)', RangeError);
  assert_throws('from(a).single(i => i < 0)', RangeError);

  assert_equals('from([1]).singleOrDefault(NaN)', 1);
  assert_throws('from(a).singleOrDefault(NaN)', RangeError);
  assert_equals('from([]).singleOrDefault(NaN)', NaN);
  assert_equals('from(a).singleOrDefault(NaN, i => i > 3)', 4);
  assert_throws('from(a).singleOrDefault(NaN, i => i > 2)', RangeError);
  assert_equals('from(a).singleOrDefault(NaN, i => i < 0)', NaN);

  assert_equals('from(a).skip(2)', [2, 3, 4]);
  assert_nothrow('from(lazy()).skip(2)', 'is lazy');
  assert_chains('from(a).skip(2)');

  assert_equals('from(a).skipWhile(i=>i<2)', [2, 3, 4]);
  assert_equals('from(a).skipWhile((v,i)=>i<2)', [2, 3, 4]);
  assert_nothrow('from(lazy()).skipWhile(i=>i<2)', 'is lazy');
  assert_chains('from(a).skipWhile(i=>i<2)');

  assert_equals('from(a).sum()', 10);
  assert_equals('from(a).sum(i=>i*i)', 30);

  assert_equals('from(a).take(2)', [0, 1]);
  assert_equals('from(a).take(0)', []);
  assert_equals('from(a).take(100)', a);
  assert_nothrow('from(lazy()).take(2)', 'is lazy');
  assert_chains('from(a).take(2)');

  assert_equals('from(a).takeWhile(i => i != 3)', [0, 1, 2]);
  assert_equals('from(a).takeWhile((v,i) => i != 3)', [0, 1, 2]);
  assert_nothrow('from(lazy()).takeWhile(i => i != 3)', 'is lazy');
  assert_chains('from(a).takeWhile(i => i != 3)');

  assert_equals('from(keyed).orderBy(p => p.pk).thenBy(p => p.sk).select(p => p.name)',
                ['b', 'd', 'e', 'a', 'c']);
  assert_equals('from(keyed).orderByDescending(p => p.pk).thenBy(p => p.sk).select(p => p.name)',
                ['c', 'e', 'a', 'b', 'd']);
  assert_equals('from(keyed).orderBy(p => p.pk).thenByDescending(p => p.sk).select(p => p.name)',
                ['d', 'b', 'a', 'e', 'c']);
  assert_equals('from(keyed).orderByDescending(p => p.pk).thenByDescending(p => p.sk).select(p => p.name)',
                ['c', 'a', 'e', 'd', 'b']);
  assert_equals('from(a).orderBy(e => e).thenBy(e => e).thenBy(e => e)', a);
  assert_equals('from(a).orderBy(e => e).thenBy(e => e).orderByDescending(e => e)', [4, 3, 2, 1, 0]);
  assert_throws('from(a).thenBy(e => e)', TypeError);
  assert_throws('from(a).orderBy(e => e).select(e => e).thenBy(e => e)', TypeError);
  assert_nothrow('from(lazy()).orderBy(e => e).thenBy(e => e)', 'is lazy');

  assert_equals('from(a).union([4, 5, 6])', [0, 1, 2, 3, 4, 5, 6]);
  assert_equals('from([1,1]).union([2, 2])', [1, 2]);
  assert_equals('from(mixed).union(["2", "4", 6], itype)', [1, 2, 3, '4', 6]);
  assert_equals('from([1,"1"]).union(["2", 2], itype)', [1, '2']);
  assert_nothrow('from(lazy()).union([4, 5, 6])', 'is lazy');
  assert_chains('from(a).union([4, 5, 6])');

  assert_equals('from(a).where(odd)', [1, 3]);
  assert_equals('from(a).where((v, i) => i > 2)', [3, 4]);
  assert_nothrow('from(lazy()).where(odd)', 'is lazy');

  assert_equals('from(a).zip([7, 6, 5]).elementAt(0)', [0, 7]);
  assert_equals('from(a).zip([7, 6, 5]).elementAt(1)', [1, 6]);
  assert_equals('from(a).zip([7, 6, 5]).elementAt(2)', [2, 5]);
  assert_nothrow('from(lazy()).zip(lazy())', 'is lazy');

  // Iterable
  assert_equals('from(a)', [0, 1, 2, 3, 4]);
  assert_nothrow('from(lazy())', 'is lazy');
});
</script>
