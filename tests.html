<!DOCTYPE html>
<title>from.js - "LINQ"ish helpers for ECMAScript</title>
<style>
#results .pass::before { content: 'PASS: '; }
#results .pass { color: black; }
#results .fail::before { content: 'FAIL: '; }
#results .fail { color: red; }
#results .pass, .fail { font-family: 'monospace'; font-size: 10pt; }
</style>

<script src="from.js"></script>

<div id="results"></div>
<script>
var a = [0, 1, 2, 3, 4];
var people = [{id: 123, name: 'alice'}, {id: 7, name: 'bob'}];
var pets = [{name: 'daisy', owner: 123}, {name: 'fido', owner: 7}, {name: 'speak', owner: 123}];
var keyed = [
  {pk: 5, sk: 14, name: 'a'},
  {pk: 4, sk: 15, name: 'b'},
  {pk: 6, sk: 13, name: 'c'},
  {pk: 4, sk: 16, name: 'd'},
  {pk: 5, sk: 12, name: 'e'}
];
var mixed = [1, 2, 3, '1', '2', '3'];
var lazy = function*() { throw new Error('should not be called'); };

var square = n => n * n;
var odd = n => !!(n % 2);
var even = n => !(n % 2);
var sum = (a, b) => a + b;
var cmp = (a, b) => a < b ? -1 : a > b ? 1 : 0;
var icase = (a, b) => String(a).toUpperCase() === String(b).toUpperCase();
var itype = (a, b) => a == b;

function array_equal(a, b) {
  if (a.length !== b.length) return false;
  for (var i = 0; i < a.length; ++i)
    if (!Object.is(a[i] , b[i])) return false;
  return true;
}
function log(message, className) {
  var div = document.createElement('div');
  if (className) div.classList.add(className);
  div.appendChild(document.createTextNode(message));
  document.querySelector('#results').appendChild(div);
}
window.onerror = function(a) { log(a, 'fail'); }
function assert_equals(expr, expected) {
  if (typeof expr !== 'string') throw Error('Expected expression string');
  try {
    var actual = (1,eval)(expr);
  } catch (ex) {
    log(expr + ' threw ' + ex.name + ' ' + JSON.stringify(ex.message), 'fail');
    return;
  }
  if (!Array.isArray(expected)) {
    if (Object.is(actual, expected))
      log(expr + ' => ' + String(actual), 'pass');
    else
      log(expr + ' expected: ' + String(expected) + ', actual: ' + String(actual), 'fail');
  } else if (!(Symbol.iterator in actual)) {
    log(expr + ' expected: ' + String(expected) + ', actual: ' + String(actual), 'fail');
  } else {
    actual = Array.from(actual);
    if (array_equal(actual, expected))
      log(expr + ' => ' + String(actual), 'pass');
    else
      log(expr + ' expected: ' + String(expected) + ', actual: ' + String(actual), 'fail');
  }
}
function assert_throws(expr) {
  if (typeof expr !== 'string') throw Error('Expected expression string');
  try {
    var actual = (1,eval)(expr);
    log(expr + ' expected exception, none thrown', 'fail');
  } catch (ex) {
    log(expr + ' => threw ' + ex.name + ' ' + JSON.stringify(ex.message), 'pass');
  }
}
function assert_nothrow(expr) {
  if (typeof expr !== 'string') throw Error('Expected expression string');
  try {
    var actual = (1,eval)(expr);
    log(expr + ' did not throw', 'pass');
  } catch (ex) {
    log(expr + ' => threw ' + ex.name + ' ' + JSON.stringify(ex.message), 'fail');
  }
}

// ---------------------------------------------------------------

assert_equals('from(a).aggregate(sum)', 10);
assert_equals('from(a).aggregate(sum, 100)', 110);
assert_equals('from(a).aggregate(sum, 0, r=>"$"+r)', '$10');

assert_equals('from(a).all(odd)', false);
assert_equals('from(a).all(i => i >= 0)', true);

assert_equals('from(a).any(odd)', true);
assert_equals('from(a).any(i => i > 5)', false);

assert_equals('from(a).average()', 2);
assert_equals('from(a).average(i=>i*10)', 20);

assert_equals('from(a).concat(a)', [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]);
assert_nothrow('from(lazy()).concat(lazy())');
assert_nothrow('from(a).concat(a).select(e=>e)');

assert_equals('from(a).contains(1)', true);
assert_equals('from(a).contains(13)', false);
assert_equals('from(["a"]).contains(["A"], icase)', true);
assert_equals('from(["a"]).contains(["B"], icase)', false);

assert_equals('from(a).count()', 5);
assert_equals('from(a).count(i=>i>0)', 4);

assert_equals('from([1,2]).defaultIfEmpty("a")', [1, 2]);
assert_equals('from([]).defaultIfEmpty("a")', ['a']);
assert_nothrow('from(lazy()).defaultIfEmpty("a")');

assert_equals('from([1,2,3,1,2,3]).distinct()', [1, 2, 3]);
assert_equals('from(mixed).distinct(itype)', [1, 2, 3]);
assert_nothrow('from(lazy()).distinct()');

assert_equals('from(a).elementAt(2)', 2);
assert_throws('from(a).elementAt(-1)');
assert_throws('from(a).elementAt(7)');

assert_equals('from(a).elementAtOrDefault(2, NaN)', 2);
assert_equals('from(a).elementAtOrDefault(-1, NaN)', NaN);
assert_equals('from(a).elementAtOrDefault(7, NaN)', NaN);

assert_equals('Enumerable.empty()', []);

assert_equals('from(a).except([2, 3])', [0, 1, 4]);
assert_equals('from(mixed).except([2], itype)', [1, 3, '1', '3']);
assert_nothrow('from(lazy()).except([2, 3])');
assert_nothrow('from(a).except([2, 3]).select(i=>i)');

assert_equals('from(a).first()', 0);
assert_equals('from(a).first(odd)', 1);
assert_throws('from([]).first()');
assert_throws('from(a).first(i=>i<0)');

assert_equals('from(a).firstOrDefault("a")', 0);
assert_equals('from(a).firstOrDefault("a", odd)', 1);
assert_equals('from([]).firstOrDefault("a")', 'a');
assert_equals('from(a).firstOrDefault("a", i=>i<0)', 'a');

assert_equals('from(keyed).groupBy(r=>r.pk).count()', 3);
assert_equals('from(keyed).groupBy(r=>r.pk).select(g=>g[0])', [5, 4, 6]);
assert_equals('from(keyed).groupBy(r=>r.pk).select(g=>g[1]).elementAt(0).map(o=>o.name)', ['a', 'e']);
assert_equals('from(keyed).groupBy(r=>r.pk).select(g=>g[1]).elementAt(1).map(o=>o.name)', ['b', 'd']);
assert_equals('from(keyed).groupBy(r=>r.pk).select(g=>g[1]).elementAt(2).map(o=>o.name)', ['c']);
assert_equals('from(keyed).groupBy(r=>r.pk, (a,b)=>!((a+b)%2)).count()', 2);
assert_equals('from(keyed).groupBy(r=>r.pk, (a,b)=>!((a+b)%2)).select(g=>g[0])', [5, 4]);
assert_nothrow('from(lazy()).groupBy(odd)');

assert_equals('from(a).intersect([2, 3, 5])', [2, 3]);
assert_equals('from(mixed).intersect([2, 5], itype)', [2]);
assert_nothrow('from(lazy()).intersect([2, 3, 5])');
assert_nothrow('from(a).intersect([2, 3, 5]).select(i=>i)');

assert_equals('from(people).join(pets, o=>o.id, i=>i.owner, (o, p) => o.name + " - " + p.name)',
  ['alice - daisy', 'alice - speak', 'bob - fido']
);
assert_equals('from(people).join(pets, o=>o.id, i=>String(i.owner), (o, p) => o.name + " - " + p.name, itype)',
  ['alice - daisy', 'alice - speak', 'bob - fido']
);
assert_nothrow('from(lazy()).join(lazy(), i => i, i => i, (a, b) => 0)');

assert_equals('from(a).last()', 4);
assert_equals('from(a).last(odd)', 3);
assert_throws('from([]).last()');
assert_throws('from(a).last(i=>i<0)');

assert_equals('from([1, 2, 3]).lastOrDefault(NaN)', 3);
assert_equals('from([]).lastOrDefault(NaN)', NaN);
assert_equals('from([1, 2, 3]).lastOrDefault(NaN, i => i < 2)', 1);
assert_equals('from([1, 2, 3]).lastOrDefault(NaN, i => i > 5)', NaN);

assert_equals('from(a).max()', 4);
assert_equals('from(a).max(i=>-i)', 0);
assert_throws('from([]).max()');

assert_equals('from(a).min()', 0);
assert_equals('from(a).min(i=>-i)', 4);
assert_throws('from([]).min()');

assert_equals('from(people).orderBy(e=>e.id).select(e=>e.name)', ['bob', 'alice']);
assert_equals('from(people).orderBy(e=>e.id,(a,b)=>-cmp(a,b)).select(e=>e.name)', ['alice', 'bob']);
assert_nothrow('from(lazy()).orderBy(e=>e)');

assert_equals('from(people).orderByDescending(e=>e.id).select(e=>e.name)', ['alice', 'bob']);
assert_equals('from(people).orderByDescending(e=>e.id,(a,b)=>-cmp(a,b)).select(e=>e.name)', ['bob', 'alice']);
assert_nothrow('from(lazy()).orderByDescending(e=>e)');

assert_equals('Enumerable.range(5, 3)', [5, 6, 7]);

assert_equals('Enumerable.repeat(1, 2)', [1, 1]);

assert_equals('from(a).reverse()', [4, 3, 2, 1, 0]);
assert_nothrow('from(lazy()).reverse()', [4, 3, 2, 1, 0]);

assert_equals('from(a).select(square)', [0, 1, 4, 9, 16]);
assert_equals('from("abc").select((i,n)=>i+n)', ['a0', 'b1', 'c2']);
assert_nothrow('from(lazy()).select(square)');
assert_nothrow('from(a).select(square).select(i=>i)');

assert_equals('from([{n:[1,2]}, {n:[3,4]}]).selectMany(o=>o.n)', [1, 2, 3, 4]);
assert_equals('from([{n:["a","b"]}, {n:["c"]}]).selectMany((o,i)=>o.n.map(c=>c+i))', ['a0', 'b0', 'c1']);
assert_equals('from([{s: "a", n:[1,2]}, {s: "b", n:[3,4]}]).selectMany(o=>o.n, (a, b) => a.s + "/" + b)', ['a/1', 'a/2', 'b/3', 'b/4']);
assert_nothrow('from(lazy()).selectMany(o=>o.n)');

assert_equals('from(a).sequenceEqual(a)', true);
assert_equals('from(a).sequenceEqual([4,3,2,1,0])', false);
assert_equals('from(a).sequenceEqual([])', false);
assert_equals('from(a).sequenceEqual(["0", "1", "2", "3", "4"], itype)', true);

assert_equals('from([1]).single()', 1);
assert_throws('from(a).single()');
assert_throws('from([]).single()');
assert_equals('from(a).single(i => i > 3)', 4);
assert_throws('from(a).single(i => i > 2)');
assert_throws('from(a).single(i => i < 0)');

assert_equals('from([1]).singleOrDefault(NaN)', 1);
assert_throws('from(a).singleOrDefault(NaN)');
assert_equals('from([]).singleOrDefault(NaN)', NaN);
assert_equals('from(a).singleOrDefault(NaN, i => i > 3)', 4);
assert_throws('from(a).singleOrDefault(NaN, i => i > 2)');
assert_equals('from(a).singleOrDefault(NaN, i => i < 0)', NaN);

assert_equals('from(a).skip(2)', [2, 3, 4]);
assert_nothrow('from(lazy()).skip(2)');
assert_nothrow('from(a).skip(2).select(i=>i)');

assert_equals('from(a).sum()', 10);
assert_equals('from(a).sum(i=>i*i)', 30);

assert_equals('from(a).take(2)', [0, 1]);
assert_equals('from(a).take(0)', []);
assert_equals('from(a).take(100)', a);
assert_nothrow('from(lazy()).take(2)');
assert_nothrow('from(a).take(2).select(i=>i)');

assert_equals('from(a).takeWhile(i => i != 3)', [0, 1, 2]);
assert_equals('from(a).takeWhile((v,i) => i != 3)', [0, 1, 2]);
assert_nothrow('from(lazy()).takeWhile(i => i != 3)');
assert_nothrow('from(a).takeWhile(i => i != 3).select(i=>i)');

assert_equals('from(keyed).orderBy(p => p.pk).thenBy(p => p.sk).select(p => p.name)',
  ['b', 'd', 'e', 'a', 'c']);
assert_equals('from(keyed).orderByDescending(p => p.pk).thenBy(p => p.sk).select(p => p.name)',
  ['c', 'e', 'a', 'b', 'd']);
assert_equals('from(keyed).orderBy(p => p.pk).thenByDescending(p => p.sk).select(p => p.name)',
  ['d', 'b', 'a', 'e', 'c']);
assert_equals('from(keyed).orderByDescending(p => p.pk).thenByDescending(p => p.sk).select(p => p.name)',
  ['c', 'a', 'e', 'd', 'b']);
assert_equals('from(a).orderBy(e => e).thenBy(e => e).thenBy(e => e)', a);
assert_equals('from(a).orderBy(e => e).thenBy(e => e).orderByDescending(e => e)', [4, 3, 2, 1, 0]);
assert_throws('from(a).thenBy(e => e)');
assert_throws('from(a).orderBy(e => e).select(e => e).thenBy(e => e)');
assert_nothrow('from(lazy()).orderBy(e => e).thenBy(e => e)');

assert_equals('from(a).union([4, 5, 6])', [0, 1, 2, 3, 4, 5, 6]);
assert_equals('from([1,1]).union([2, 2])', [1, 2]);
assert_equals('from(mixed).union(["2", "4", 6], itype)', [1, 2, 3, '4', 6]);
assert_equals('from([1,"1"]).union(["2", 2], itype)', [1, '2']);
assert_nothrow('from(lazy()).union([4, 5, 6])');
assert_nothrow('from(a).union([4, 5, 6]).select(i=>i)');

assert_equals('from(a).where(odd)', [1, 3]);
assert_equals('from(a).where((v, i) => i > 2)', [3, 4]);
assert_nothrow('from(lazy()).where(odd)');

assert_equals('from(a).zip([7, 6, 5]).elementAt(0)', [0, 7]);
assert_equals('from(a).zip([7, 6, 5]).elementAt(1)', [1, 6]);
assert_equals('from(a).zip([7, 6, 5]).elementAt(2)', [2, 5]);
assert_nothrow('from(lazy()).zip(lazy())');

// Iterable
assert_equals('from(a)', [0, 1, 2, 3, 4]);
assert_nothrow('from(lazy())');

</script>

<p>
The use of "LINQ" is search-engine bait.
<a href="https://msdn.microsoft.com/en-us/library/bb397926.aspx">LINQ is "Language-Integrated Query"</a> which
adds syntax to languages like C#, so you can write code like
<code>var cs = from r in data where r.flag select r.foo;</code>.
</p>